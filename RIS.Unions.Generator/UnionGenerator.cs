// Copyright (c) RISStudio, 2020. All rights reserved.
// Licensed under the Apache License, Version 2.0. See LICENSE file in the project root for license information.

using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RIS.Unions.Generator
{
    [Generator]
    public class UnionGenerator : IIncrementalGenerator
    {
        private const string UnionBaseTypeNamespace = "RIS.Unions";

        private const string AttributeName = "GenerateUnionAttribute";
        private const string AttributeNamespace = "RIS.Unions";
        private const string AttributeFullyQualifiedName = $"global::{AttributeNamespace}.{AttributeName}";
        private const string AttributeText = $@"// <auto-generated />

#pragma warning disable 1591

using System;

namespace {AttributeNamespace}
{{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class {AttributeName} : Attribute
    {{
        public string[] TypeNames {{ get; }}

        public {AttributeName}(params string[] typeNames)
        {{
            this.TypeNames = typeNames;
        }}
    }}
}}";



        public void Initialize(
            IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(contextPost =>
                contextPost.AddSource($"{AttributeName}.g.cs", AttributeText));

            context.RegisterSourceOutput(
                GetTargetClasses(context),
                Execute);
        }

        public static void Execute(
            SourceProductionContext context,
            ImmutableArray<INamedTypeSymbol?> classSymbols)
        {
            foreach (var classSymbol in classSymbols)
            {
                if (classSymbol == null)
                    continue;

                var attributeData = classSymbol
                    .GetAttributes()
                    .First(data =>
                        string.Equals(
                            data.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                            AttributeFullyQualifiedName));

                var classSource = ProcessClass(
                    context, classSymbol, attributeData);

                if (classSource is null)
                    continue;

                context.AddSource(
                    $"{classSymbol.ContainingNamespace}_{classSymbol.Name}.g.cs",
                    classSource);
            }
        }



        private static IncrementalValueProvider<ImmutableArray<INamedTypeSymbol?>> GetTargetClasses(
            IncrementalGeneratorInitializationContext context)
        {
            return context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (node, _) => IsSyntaxTarget(node),
                    (syntaxContext, _) => GetSemanticTarget(syntaxContext))
                .Where(static classSymbol => classSymbol is not null)
                .Collect();
        }

        private static bool IsSyntaxTarget(
            SyntaxNode node)
        {
            return node is ClassDeclarationSyntax { AttributeLists: { Count: > 0 } } classDeclarationSyntax
                   && classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
        }

        private static INamedTypeSymbol? GetSemanticTarget(
            GeneratorSyntaxContext context)
        {
            var symbol = context.SemanticModel
                .GetDeclaredSymbol(context.Node);

            if (symbol is not INamedTypeSymbol classSymbol)
                return null;

            var attributeData = classSymbol
                .GetAttributes()
                .FirstOrDefault(data =>
                    string.Equals(
                        data.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                        AttributeFullyQualifiedName));

            return attributeData is null
                ? null
                : classSymbol;
        }



        private static string? ProcessClass(
            SourceProductionContext context,
            INamedTypeSymbol classSymbol,
            AttributeData attributeData)
        {
            if (!context.ValidateClass(classSymbol))
                return null;
            if (!context.ValidateTypeArguments(classSymbol))
                return null;
            if (!context.ValidateTypeNames(classSymbol, attributeData))
                return null;

            return GenerateClassSource(
                classSymbol,
                classSymbol.BaseType!.TypeParameters,
                classSymbol.BaseType!.TypeArguments,
                attributeData);
        }

        private static string GenerateClassSource(
            INamedTypeSymbol classSymbol,
            ImmutableArray<ITypeParameterSymbol> typeParameters,
            ImmutableArray<ITypeSymbol> typeArguments,
            AttributeData attributeData)
        {
            var typeNames =
                attributeData.ConstructorArguments
                    .First()
                    .Values;
            var paramArgsPairs =
                typeParameters
                    .Zip(typeArguments, (param, arg) =>
                        (param, arg))
                    .ToArray();
            var paramArgsAndNames =
                paramArgsPairs
                    .Zip(typeNames, (pa, name) =>
                        (pa.param, pa.arg, name))
                    .ToArray();
            var genericPart =
                GetGenericPart(typeArguments);
            var classNameWithGenericTypes =
                $"{classSymbol.Name}{GetOpenGenericPart(classSymbol)}";

            StringBuilder source = new($@"// <auto-generated />

#pragma warning disable 1591

using System;
using {UnionBaseTypeNamespace};

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{
    partial class {classNameWithGenericTypes}");

            source.Append($@"
    {{
        public {classSymbol.Name}(Union<{genericPart}> _)
            : base(_)
        {{

        }}
");

            source.Append(@"

");

            foreach (var (param, arg, name) in paramArgsAndNames)
            {
                source.Append($@"
        {RoslynFactory.CreatePropertyIsX(param, arg, name)}
        {RoslynFactory.CreatePropertyAsX(param, arg, name)}
        {RoslynFactory.CreateMethodTryPickX(paramArgsPairs, param, arg, name)}
");
            }

            source.Append(@"

");

            foreach (var (param, arg) in paramArgsPairs)
            {
                source.Append($@"
        public static implicit operator {classNameWithGenericTypes}({arg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} _) => new {classNameWithGenericTypes}(_);
        public static explicit operator {arg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}({classNameWithGenericTypes} _) => _.As{param.Name};
");
            }

            source.Append(@"    }
}");

            return source.ToString();
        }


        private static string GetGenericPart(
            ImmutableArray<ITypeSymbol> typeArguments)
        {
            return string.Join(", ",
                typeArguments.Select(typeArgument =>
                    typeArgument.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
        }

        private static string? GetOpenGenericPart(
            INamedTypeSymbol classSymbol)
        {
            return classSymbol.TypeArguments.Any()
                ? $"<{GetGenericPart(classSymbol.TypeArguments)}>"
                : null;
        }
    }
}
