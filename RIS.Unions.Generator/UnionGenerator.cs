using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace RIS.Unions.Generator
{
    [Generator]
    public class UnionGenerator : ISourceGenerator
    {
        private const string UnionBaseTypeNamespace = "RIS.Unions";

        private const string AttributeName = "GenerateUnionAttribute";
        private const string AttributeNamespace = "RIS.Unions";
        private const string AttributeText = $@"// <auto-generated />

#pragma warning disable 1591

using System;

namespace {AttributeNamespace}
{{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class {AttributeName} : Attribute
    {{
        public string[] TypeNames {{ get; }}

        public {AttributeName}(params string[] typeNames)
        {{
            this.TypeNames = typeNames;
        }}
    }}
}}
        ";



        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() =>
                new UnionSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            context.AddSource($"{AttributeName}.g.cs",
                SourceText.From(AttributeText, Encoding.UTF8));

            if (context.SyntaxReceiver is not UnionSyntaxReceiver receiver)
                return;
            if ((context.Compilation as CSharpCompilation)?.SyntaxTrees[0].Options is not CSharpParseOptions options)
                return;

            var compilation =
                context.Compilation.AddSyntaxTrees(
                    CSharpSyntaxTree.ParseText(
                        SourceText.From(AttributeText, Encoding.UTF8), options));
            var attributeSymbol =
                compilation.GetTypeByMetadataName(
                    $"{AttributeNamespace}.{AttributeName}");

            if (attributeSymbol is null)
                return;

            List<(INamedTypeSymbol, AttributeData?)> namedTypeSymbols = new();

            foreach (var classDeclaration in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(
                    classDeclaration.SyntaxTree);
                var namedTypeSymbol = model.GetDeclaredSymbol(
                    classDeclaration);

                var attributeData = namedTypeSymbol?
                    .GetAttributes()
                    .FirstOrDefault(ad =>
                        ad.AttributeClass?.Equals(attributeSymbol, SymbolEqualityComparer.Default) != false);

                if (attributeData is null)
                    continue;

                namedTypeSymbols.Add((namedTypeSymbol!, attributeData));
            }

            foreach (var (namedSymbol, attributeData) in namedTypeSymbols)
            {
                var classSource = ProcessClass(
                    namedSymbol, context, attributeData!);

                if (classSource is null)
                    continue;

                context.AddSource($"{namedSymbol.ContainingNamespace}_{namedSymbol.Name}.g.cs",
                    SourceText.From(classSource, Encoding.UTF8));
            }
        }

        private static string? ProcessClass(INamedTypeSymbol classSymbol,
            GeneratorExecutionContext context, AttributeData attributeData)
        {
            if (!context.ValidateClass(classSymbol, attributeData))
                return null;
            if (!context.ValidateTypeArguments(classSymbol, attributeData))
                return null;
            if (!context.ValidateTypeNames(classSymbol, attributeData))
                return null;

            return GenerateClassSource(classSymbol,
                classSymbol.BaseType!.TypeParameters,
                classSymbol.BaseType!.TypeArguments,
                attributeData);
        }

        private static string GenerateClassSource(INamedTypeSymbol classSymbol,
            ImmutableArray<ITypeParameterSymbol> typeParameters,
            ImmutableArray<ITypeSymbol> typeArguments,
            AttributeData attributeData)
        {
            var typeNames =
                attributeData.ConstructorArguments
                    .First()
                    .Values;
            var paramArgsPairs =
                typeParameters
                    .Zip(typeArguments, (param, arg) =>
                        (param, arg))
                    .ToArray();
            var paramArgsAndNames =
                paramArgsPairs
                    .Zip(typeNames, (pa, name) =>
                        (pa.param, pa.arg, name))
                    .ToArray();
            var genericPart =
                GetGenericPart(typeArguments);
            var classNameWithGenericTypes =
                $"{classSymbol.Name}{GetOpenGenericPart(classSymbol)}";

            StringBuilder source = new($@"// <auto-generated />

#pragma warning disable 1591

using System;
using {UnionBaseTypeNamespace};

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{
    public partial class {classNameWithGenericTypes}");

            source.Append($@"
    {{
        public {classSymbol.Name}(Union<{genericPart}> _)
            : base(_)
        {{

        }}
");

            source.Append(@"

");

            foreach (var (param, arg, name) in paramArgsAndNames)
            {
                source.Append($@"
        {RoslynFactory.CreatePropertyIsX(param, arg, name)}
        {RoslynFactory.CreatePropertyAsX(param, arg, name)}
        {RoslynFactory.CreateMethodTryPickX(paramArgsPairs, param, arg, name)}
");
            }

            source.Append(@"

");

            foreach (var (param, arg) in paramArgsPairs)
            {
                source.Append($@"
        public static implicit operator {classNameWithGenericTypes}({arg.ToDisplayString()} _) => new {classNameWithGenericTypes}(_);
        public static explicit operator {arg.ToDisplayString()}({classNameWithGenericTypes} _) => _.As{param.Name};
");
            }

            source.Append(@"    }
}");

            return source.ToString();
        }

        private static string GetGenericPart(
            ImmutableArray<ITypeSymbol> typeArguments)
        {
            return string.Join(", ",
                typeArguments.Select(x => x.ToDisplayString()));
        }

        private static string? GetOpenGenericPart(
            INamedTypeSymbol classSymbol)
        {
            if (!classSymbol.TypeArguments.Any())
                return null;

            return $"<{GetGenericPart(classSymbol.TypeArguments)}>";
        }
    }
}
 