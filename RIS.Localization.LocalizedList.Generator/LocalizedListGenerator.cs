// Copyright (c) RISStudio, 2020. All rights reserved.
// Licensed under the Apache License, Version 2.0. See LICENSE file in the project root for license information.

using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RIS.Localization.LocalizedList.Generator
{
    [Generator]
    public class LocalizedListGenerator : IIncrementalGenerator
    {
        private const string LocalizedListBaseTypeNamespace = "RIS.Localization";
        private const string LocalizedListBaseTypeName = "LocalizedListBase";



        public void Initialize(
            IncrementalGeneratorInitializationContext context)
        {
            context.RegisterSourceOutput(
                GetTargetClasses(context),
                Execute);
        }

        public static void Execute(
            SourceProductionContext context,
            ImmutableArray<INamedTypeSymbol?> classSymbols)
        {
            foreach (var classSymbol in classSymbols)
            {
                if (classSymbol == null)
                    continue;

                var classSource = ProcessClass(
                    context, classSymbol);

                if (classSource is null)
                    continue;

                context.AddSource(
                    $"{classSymbol.ContainingNamespace}_{classSymbol.Name}.g.cs",
                    classSource);
            }
        }



        private static IncrementalValueProvider<ImmutableArray<INamedTypeSymbol?>> GetTargetClasses(
            IncrementalGeneratorInitializationContext context)
        {
            return context.SyntaxProvider
                .CreateSyntaxProvider(
                    static (node, _) => IsSyntaxTarget(node),
                    (syntaxContext, _) => GetSemanticTarget(syntaxContext))
                .Where(static classSymbol => classSymbol is not null)
                .Collect();
        }

        private static bool IsSyntaxTarget(
            SyntaxNode node)
        {
            return node is ClassDeclarationSyntax { BaseList: { Types: { Count: > 0 } } } classDeclarationSyntax
                   && classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
        }

        private static INamedTypeSymbol? GetSemanticTarget(
            GeneratorSyntaxContext context)
        {
            var symbol = context.SemanticModel
                .GetDeclaredSymbol(context.Node);

            if (symbol is not INamedTypeSymbol classSymbol)
                return null;

            var baseClassSymbol = classSymbol;

            do
            {
                baseClassSymbol = baseClassSymbol.BaseType;
            } while (baseClassSymbol?.BaseType != null
                     && baseClassSymbol.BaseType?.SpecialType != SpecialType.System_Object);

            if (classSymbol.IsAbstract
                || baseClassSymbol is null
                || baseClassSymbol.Name != LocalizedListBaseTypeName
                || baseClassSymbol.ContainingNamespace.ToString() != LocalizedListBaseTypeNamespace)
            {
                return null;
            }

            return classSymbol;
        }



        private static string? ProcessClass(
            SourceProductionContext context,
            INamedTypeSymbol classSymbol)
        {
            if (!context.ValidateClass(classSymbol))
                return null;

            return GenerateClassSource(
                classSymbol);
        }

        private static string GenerateClassSource(
            INamedTypeSymbol classSymbol)
        {
            var classNameWithGenericTypes =
                $"{classSymbol.Name}{GetOpenGenericPart(classSymbol)}";

            StringBuilder source = new($@"// <auto-generated />

#pragma warning disable 1591

using System;
using System.ComponentModel;
using {LocalizedListBaseTypeNamespace};

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{
    partial class {classNameWithGenericTypes}
    {{
        {RoslynFactory.CreateEventStaticPropertyChanged()}
");

            source.Append($@"


        {RoslynFactory.CreateInstanceProperty(classSymbol)}
");

            source.Append(@"    }
}");

            return source.ToString();
        }



        private static string GetGenericPart(
            ImmutableArray<ITypeSymbol> typeArguments)
        {
            return string.Join(", ",
                typeArguments.Select(typeArgument =>
                    typeArgument.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
        }

        private static string? GetOpenGenericPart(
            INamedTypeSymbol classSymbol)
        {
            return classSymbol.TypeArguments.Any()
                ? $"<{GetGenericPart(classSymbol.TypeArguments)}>"
                : null;
        }
    }
}
